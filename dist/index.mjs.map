{"version":3,"file":"index.mjs","sources":["../src/tools.js","../src/data.js","../src/batcher.js","../src/observe.js","../src/computed.js","../src/index.js","../src/dispose.js"],"sourcesContent":["const BIND_IGNORED = [\n  'String',\n  'Number',\n  'Object',\n  'Array',\n  'Boolean',\n  'Date'\n]\n\nexport function isObj(object) { return object && typeof object === 'object' }\nexport function setHiddenKey(object, key, value) {\n  Object.defineProperty(object, key, { value, enumerable: false, configurable: true })\n}\nexport function defineBubblingProperties(object, key, parent) {\n  setHiddenKey(object, '__key', key)\n  setHiddenKey(object, '__parent', parent)\n}\nexport function getInstanceMethodKeys(object) {\n  return (\n    Object\n      .getOwnPropertyNames(object)\n      .concat(\n        Object.getPrototypeOf(object) &&\n                BIND_IGNORED.indexOf(Object.getPrototypeOf(object).constructor.name) < 0 ?\n          Object.getOwnPropertyNames(Object.getPrototypeOf(object)) :\n          []\n      )\n      .filter(prop => prop !== 'constructor' && typeof object[prop] === 'function')\n  )\n}\n","export const data = {\n  computedStack: [],\n  trackerSymbol: Symbol('tracker')\n}\n","let queue = null\nexport const __batched = Symbol()\n\n/**\n * Will perform batched computations instantly.\n */\nexport function process() {\n  if(!queue)\n    return\n  for(const task of queue) {\n    task()\n    task[__batched] = false\n  }\n  queue = null\n}\n\nexport function enqueue(task, batch) {\n  if(task[__batched])\n    return\n  if(queue === null) {\n    queue = []\n    if(batch === true) {\n      queueMicrotask(process)\n    } else {\n      setTimeout(process, batch)\n    }\n  }\n  queue.push(task)\n}\n\n","import {\n  isObj,\n  defineBubblingProperties,\n  getInstanceMethodKeys,\n  setHiddenKey\n} from './tools.js'\nimport { data } from './data.js'\nimport { enqueue, __batched } from './batcher.js'\n\nconst { computedStack, trackerSymbol } = data\n\nconst observedSymbol = Symbol('__observed')\n\n/**\n * @typedef {Object} Options - Observe options.\n * @property {string[]} [props] - Observe only the properties listed.\n * @property {string[]} [ignore] - Ignore the properties listed.\n * @property {boolean | number} [batch] -\n *  Batch computed properties calls, wrapping them in a queueMicrotask and\n *  executing them in a new context and preventing excessive calls.\n *  If batch is an integer, the calls will be debounced by the value in milliseconds using setTimemout.\n * @prop {boolean} [deep] - Recursively observe nested objects and when setting new properties.\n * @prop {boolean} [bind] - Automatically bind methods to the observed object.\n */\n\n/**\n * Observes an object or an array and returns a proxified version which reacts on mutations.\n *\n * @template O\n * @param {O} obj - The object to observe.\n * @param {Options} options - Options\n * @returns {O} - A proxy wrapping the object.\n */\nexport function observe(obj, options = {}) {\n  // 'deep' is slower but reasonable; 'shallow' a performance enhancement but with side-effects\n  const {\n    props,\n    ignore,\n    batch,\n    deep = true,\n    bubble,\n    bind\n  } = options\n\n  // Ignore if the object is already observed\n  if(obj[observedSymbol]) {\n    return obj\n  }\n\n  // If the prop is explicitely not excluded\n  const isWatched = (prop) =>\n    prop !== observedSymbol &&\n    (\n      (props == null) ||\n      (props instanceof Array) && props.includes(prop)\n    ) && (\n      (ignore == null) ||\n      (ignore instanceof Array) && ! ignore.includes(prop)\n    )\n\n  // If the deep flag is set, observe nested objects/arrays\n  if(deep) {\n    Object.entries(obj).forEach(function([key, val]) {\n      if(isObj(val) && isWatched(key)) {\n        obj[key] = observe(val, options)\n        // If bubble is set, we add keys to the object used to bubble up the mutation\n        if(bubble) {\n          defineBubblingProperties(obj[key], key, obj)\n        }\n      }\n    })\n  }\n\n  // For each observed object, each property is mapped with a set of computed functions depending on this property.\n  // Whenever a property is set, we re-run each one of the functions stored inside the matching Set.\n  const propertiesMap = new Map()\n\n  // Proxify the object in order to intercept get/set on props\n  const proxy = new Proxy(obj, {\n    get(_, prop) {\n      if(prop === observedSymbol)\n        return true\n\n      // If the prop is watched\n      if(isWatched(prop)) {\n        // If a computed function is being run\n        if(computedStack.length) {\n          const computedFn = computedStack[0]\n          // Tracks object and properties accessed during the function call\n          const tracker = computedFn[trackerSymbol]\n          if(tracker) {\n            let trackerSet = tracker.get(obj)\n            if(!trackerSet) {\n              trackerSet = new Set()\n              tracker.set(obj, trackerSet)\n            }\n            trackerSet.add(prop)\n          }\n          // Link the computed function and the property being accessed\n          let propertiesSet = propertiesMap.get(prop)\n          if(!propertiesSet) {\n            propertiesSet = new Set()\n            propertiesMap.set(prop, propertiesSet)\n          }\n          propertiesSet.add(computedFn)\n        }\n      }\n\n      return obj[prop]\n    },\n    set(_, prop, value) {\n      if(prop === '__handler') {\n        // Don't track bubble handlers\n        setHiddenKey(obj, '__handler', value)\n      } else if(!isWatched(prop)) {\n        // If the prop is ignored\n        obj[prop] = value\n      } else if(Array.isArray(obj) && prop === 'length' || ValuesDiffer(obj[prop],value)) {\n        // If the new/old value are not equal\n        const deeper = deep && isObj(value)\n\n        // Remove bubbling infrastructure and pass old value to handlers\n        const oldValue = obj[prop]\n//      if(isObj(oldValue))\n//        delete obj[prop]\n\n        // If the deep flag is set we observe the newly set value\n        obj[prop] = deeper ? observe(value, options) : value\n\n        // Co-opt assigned object into bubbling if appropriate\n        if(deeper && bubble) {\n          defineBubblingProperties(obj[prop], prop, obj)\n        }\n\n        const ancestry = [ prop ]\n        let parent = obj\n        while(parent) {\n          // If a handler explicitly returns 'false' then stop propagation\n          if(parent.__handler && parent.__handler(ancestry, value, oldValue, proxy) === false) {\n            break\n          }\n          // Continue propagation, traversing the mutated property's object hierarchy & call any __handlers along the way\n          if(parent.__key && parent.__parent) {\n            ancestry.unshift(parent.__key)\n            parent = parent.__parent\n          } else {\n            parent = null\n          }\n        }\n\n        const dependents = propertiesMap.get(prop)\n        if(dependents) {\n          // Retrieve the computed functions depending on the prop\n          for(const dependent of dependents) {\n            const tracker = dependent[trackerSymbol]\n            const trackedObj = tracker && tracker.get(obj)\n            const tracked = trackedObj && trackedObj.has(prop)\n            // If the function has been disposed or if the prop has not been used\n            // during the latest function call, delete the function reference\n            if(dependent.__disposed || tracker && !tracked) {\n              dependents.delete(dependent)\n            } else if(dependent !== computedStack[0]) {\n              // Run the computed function\n              if(typeof batch !== 'undefined' && batch !== false) {\n                enqueue(dependent, batch)\n                dependent[__batched] = true\n              } else {\n                dependent()\n              }\n            }\n          }\n        }\n      }\n\n      return true\n    },\n    defineProperty(_, prop, descriptor) {\n      if (prop === '__handler') {\n      \tthrow new Error(\"Don't track bubble handlers\")\n      } else if(!isWatched(prop)) {\n        // If the prop is ignored\n        return Reflect.defineProperty(obj,prop,descriptor)\n      } else if (! Array.isArray(obj) || (prop === 'length')) {\n      \tif ('value' in descriptor) {\n      \t  descriptor = {...descriptor} // do not modify the argument itself\n      \t  descriptor.value = observe(value, options)\n      \t}\n      \treturn Reflect.defineProperty(obj,prop,descriptor)\n      }\n      return false\n    },\n    deleteProperty(_, prop) {\n    \tif (prop in obj) { obj[prop] = undefined } // trigger observers one last time\n    \treturn Reflect.deleteProperty(_,prop)\n    }\n  })\n\n  if(bind) {\n    // Need this for binding es6 classes methods which are stored in the object prototype\n    getInstanceMethodKeys(obj).forEach(key => obj[key] = obj[key].bind(proxy))\n  }\n\n  return proxy\n}\n\n/**** ValuesDiffer - copied from \"javascript-interface-library\" ****/\n\n  function ValuesDiffer (thisValue, otherValue, Mode) {\n    if (thisValue === otherValue) { return false }\n\n    let thisType = typeof thisValue\n    if (thisType !== typeof otherValue) { return true }\n\n    /**** ArraysDiffer ****/\n\n      function ArraysDiffer (thisArray, otherArray, Mode) {\n        if (! Array.isArray(otherArray)) { return true }\n\n        if (thisArray.length !== otherArray.length) { return true }\n\n        for (let i = 0, l = thisArray.length; i < l; i++) {\n          if (ValuesDiffer(thisArray[i],otherArray[i],Mode)) { return true }\n        }\n\n        return false\n      }\n\n    /**** ObjectsDiffer ****/\n\n      function ObjectsDiffer (thisObject, otherObject, Mode) {\n        if (Object.getPrototypeOf(thisObject) !== Object.getPrototypeOf(otherObject)) {\n          return true\n        }\n\n        for (let key in thisObject) {\n          if (! (key in otherObject)) { return true }\n        }\n\n        for (let key in otherObject) {\n          if (! (key in thisObject)) { return true }\n\n          if (ValuesDiffer(thisObject[key],otherObject[key],Mode)) {\n            return true\n          }\n        }\n\n        return false\n      }\n\n    switch (thisType) {\n      case 'undefined':\n      case 'boolean':\n      case 'string':\n      case 'function': return true   // most primitives are compared using \"===\"\n      case 'number':   return (\n                         (isNaN(thisValue) !== isNaN(otherValue)) ||\n                         (Math.abs(thisValue-otherValue) > Number.EPSILON)\n                       )\n      case 'object':\n        if (thisValue  == null) { return true }  // since \"other_value\" != null!\n        if (otherValue == null) { return true }   // since \"this_value\" != null!\n\n        if ((Mode === 'by-value') && (\n          (thisValue instanceof Boolean) ||\n          (thisValue instanceof Number) ||\n          (thisValue instanceof String)\n        )) {\n          return (thisValue.valueOf() !== otherValue.valueOf())\n        }\n\n        if (Array.isArray(thisValue)) {\n          return ArraysDiffer(thisValue,otherValue,Mode)\n        }\n\n        return (\n          Mode === 'by-reference'\n          ? true                           // because (thisValue !== otherValue)\n          : ObjectsDiffer(thisValue,otherValue,Mode)\n        )\n      default: return true                          // unsupported property type\n    }\n\n    return true\n  }\n","import { data } from './data.js'\nconst { computedStack, trackerSymbol } = data\n\n/**\n * @typedef {Object} ComputedArguments - Computed Arguments.\n * @property {(fun: () => void) => void} computeAsync -\n * Will monitor the dependencies of the function passed as an argument. Useful when dealing with asynchronous computations.\n */\n\n/**\n * @typedef {Object} Options - Computed Options.\n * @property {boolean} [autoRun] -\n * If false, will not run the function argument when calling computed(function).\n * The computed function must be called **at least once** to calculate its dependencies.\n * @property {() => void} [callback] -\n * Specify a callback that will be re-runned each time a dependency changes instead of the computed function.\n */\n\n/**\n * Wraps a function and captures observed properties which are accessed during the function execution.\n * When those properties are mutated, the function is called to reflect the changes.\n *\n * @param {(args: ComputedArguments) => void} wrappedFunction\n * @param {Options} options\n */\nexport function computed(wrappedFunction, { autoRun = true, callback, bind, disableTracking = false } = {}) {\n  function observeComputation(fun, argsList = []) {\n    const target = callback || wrapper\n    // Track object and object properties accessed during this function call\n    if(!disableTracking) {\n      target[trackerSymbol] = new WeakMap()\n    }\n    // Store into the stack a reference to the computed function\n    computedStack.unshift(target)\n    // Inject the computeAsync argument which is used to manually declare when the computation takes part\n    if(argsList.length > 0) {\n      argsList = [...argsList, computeAsyncArg]\n    } else {\n      argsList = [computeAsyncArg]\n    }\n    // Run the computed function - or the async function\n    const result =\n      fun ? fun() :\n      bind ? wrappedFunction.apply(bind, argsList) :\n      wrappedFunction(...argsList)\n    // Remove the reference\n    computedStack.shift()\n    // Return the result\n    return result\n  }\n  const computeAsyncArg = { computeAsync: observeComputation }\n  const wrapper = (...argsList) => observeComputation(null, argsList)\n\n  // If autoRun, then call the function at once\n  if(autoRun) {\n    wrapper()\n  }\n\n  return wrapper\n}\n","import { observe } from './observe.js'\nimport { computed } from './computed.js'\nimport { dispose } from './dispose.js'\nimport { process } from './batcher.js'\n\nexport default {\n  observe,\n  computed,\n  dispose,\n  batch: process\n}\n","import { data } from './data.js'\n\n/**\n * Will remove the computed function from the reactive Maps (the next time an bound observer property is called) allowing garbage collection.\n *\n * @param {Function} computedFunction\n */\nexport function dispose(computedFunction) {\n  computedFunction[data.trackerSymbol] = null\n  return computedFunction.__disposed = true\n}\n"],"names":["BIND_IGNORED","isObj","object","setHiddenKey","key","value","Object","defineProperty","enumerable","configurable","defineBubblingProperties","parent","data","computedStack","trackerSymbol","Symbol","queue","__batched","process","task","enqueue","batch","queueMicrotask","setTimeout","push","observedSymbol","ValuesDiffer","thisValue","otherValue","Mode","thisType","isNaN","Math","abs","Number","EPSILON","Boolean","String","valueOf","Array","isArray","thisArray","otherArray","length","i","l","ArraysDiffer","thisObject","otherObject","getPrototypeOf","ObjectsDiffer","index","observe","obj","options","props","ignore","deep","bubble","bind","isWatched","prop","includes","entries","forEach","val","propertiesMap","Map","proxy","Proxy","get","_","computedFn","tracker","trackerSet","Set","set","add","propertiesSet","deeper","oldValue","ancestry","__handler","__key","__parent","unshift","dependents","dependent","trackedObj","tracked","has","__disposed","delete","descriptor","Error","Reflect","deleteProperty","undefined","getOwnPropertyNames","concat","indexOf","constructor","name","filter","computed","wrappedFunction","autoRun","callback","disableTracking","observeComputation","fun","argsList","target","wrapper","WeakMap","computeAsyncArg","result","apply","shift","computeAsync","dispose","computedFunction"],"mappings":"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"}