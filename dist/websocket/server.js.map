{"version":3,"file":"server.js","sources":["../../src/tools.js","../../src/data.js","../../src/batcher.js","../../src/observe.js","../../src/computed.js","../../src/index.js","../../src/dispose.js","../../src/handlers/all.js","../../src/handlers/write.js","../../src/handlers/index.js","../../src/websocket/server.js"],"sourcesContent":["const BIND_IGNORED = [\n  'String',\n  'Number',\n  'Object',\n  'Array',\n  'Boolean',\n  'Date'\n]\n\nexport function isObj(object) { return object && typeof object === 'object' }\nexport function setHiddenKey(object, key, value) {\n  Object.defineProperty(object, key, { value, enumerable: false, configurable: true })\n}\nexport function defineBubblingProperties(object, key, parent) {\n  setHiddenKey(object, '__key', key)\n  setHiddenKey(object, '__parent', parent)\n}\nexport function getInstanceMethodKeys(object) {\n  return (\n    Object\n      .getOwnPropertyNames(object)\n      .concat(\n        Object.getPrototypeOf(object) &&\n                BIND_IGNORED.indexOf(Object.getPrototypeOf(object).constructor.name) < 0 ?\n          Object.getOwnPropertyNames(Object.getPrototypeOf(object)) :\n          []\n      )\n      .filter(prop => prop !== 'constructor' && typeof object[prop] === 'function')\n  )\n}\n","export const data = {\n  computedStack: [],\n  trackerSymbol: Symbol('tracker')\n}\n","let queue = null\nexport const __batched = Symbol()\n\n/**\n * Will perform batched computations instantly.\n */\nexport function process() {\n  if(!queue)\n    return\n  for(const task of queue) {\n    task()\n    task[__batched] = false\n  }\n  queue = null\n}\n\nexport function enqueue(task, batch) {\n  if(task[__batched])\n    return\n  if(queue === null) {\n    queue = []\n    if(batch === true) {\n      queueMicrotask(process)\n    } else {\n      setTimeout(process, batch)\n    }\n  }\n  queue.push(task)\n}\n\n","import {\n  isObj,\n  defineBubblingProperties,\n  getInstanceMethodKeys,\n  setHiddenKey\n} from './tools.js'\nimport { data } from './data.js'\nimport { enqueue, __batched } from './batcher.js'\n\nconst { computedStack, trackerSymbol } = data\n\nconst observedSymbol = Symbol('__observed')\n\n/**\n * @typedef {Object} Options - Observe options.\n * @property {string[]} [props] - Observe only the properties listed.\n * @property {string[]} [ignore] - Ignore the properties listed.\n * @property {boolean | number} [batch] -\n *  Batch computed properties calls, wrapping them in a queueMicrotask and\n *  executing them in a new context and preventing excessive calls.\n *  If batch is an integer, the calls will be debounced by the value in milliseconds using setTimemout.\n * @prop {boolean} [deep] - Recursively observe nested objects and when setting new properties.\n * @prop {boolean} [bind] - Automatically bind methods to the observed object.\n */\n\nexport const modifiedProperty = Symbol('modifiedProperty')\n\n/**\n * Observes an object or an array and returns a proxified version which reacts on mutations.\n *\n * @template O\n * @param {O} obj - The object to observe.\n * @param {Options} options - Options\n * @returns {O} - A proxy wrapping the object.\n */\nexport function observe(obj, options = {}) {\n  // 'deep' is slower but reasonable; 'shallow' a performance enhancement but with side-effects\n  const {\n    props,\n    ignore,\n    batch,\n    deep = true,\n    bubble,\n    bind\n  } = options\n\n  // Ignore if the object is already observed\n  if(obj[observedSymbol]) {\n    return obj\n  }\n\n  // If the prop is explicitely not excluded\n  const isWatched = (prop) =>\n    prop !== observedSymbol &&\n    (\n      (props == null) ||\n      (props instanceof Array) && props.includes(prop)\n    ) && (\n      (ignore == null) ||\n      (ignore instanceof Array) && ! ignore.includes(prop)\n    )\n\n  // If the deep flag is set, observe nested objects/arrays\n  if(deep) {\n    Object.entries(obj).forEach(function([key, val]) {\n      if(isObj(val) && isWatched(key)) {\n        obj[key] = observe(val, options)\n        // If bubble is set, we add keys to the object used to bubble up the mutation\n        if(bubble) {\n          defineBubblingProperties(obj[key], key, obj)\n        }\n      }\n    })\n  }\n  \n    function setObjectPropertyTo (obj, prop, value) {\n      if(prop === '__handler') {\n        // Don't track bubble handlers\n        setHiddenKey(obj, '__handler', value)\n      } else if(!isWatched(prop)) {\n        // If the prop is ignored\n        obj[prop] = value\n      } else if(Array.isArray(obj) && prop === 'length' || ValuesDiffer(obj[prop],value)) {\n        // If the new/old value are not equal\n        const deeper = (prop !== modifiedProperty) && deep && isObj(value)\n\n        // Remove bubbling infrastructure and pass old value to handlers\n        const oldValue = obj[prop]\n//      if(isObj(oldValue))\n//        delete obj[prop]\n\n        // If the deep flag is set we observe the newly set value\n        obj[prop] = deeper ? observe(value, options) : value\n\n        // Co-opt assigned object into bubbling if appropriate\n        if(deeper && bubble) {\n          defineBubblingProperties(obj[prop], prop, obj)\n        }\n\n        const ancestry = [ prop ]\n        let parent = obj\n        while(parent) {\n          // If a handler explicitly returns 'false' then stop propagation\n          if(parent.__handler && parent.__handler(ancestry, value, oldValue, proxy) === false) {\n            break\n          }\n          // Continue propagation, traversing the mutated property's object hierarchy & call any __handlers along the way\n          if(parent.__key && parent.__parent) {\n            ancestry.unshift(parent.__key)\n            parent = parent.__parent\n          } else {\n            parent = null\n          }\n        }\n\n        const dependents = propertiesMap.get(prop)\n        if(dependents) {\n          // Retrieve the computed functions depending on the prop\n          for(const dependent of dependents) {\n            const tracker = dependent[trackerSymbol]\n            const trackedObj = tracker && tracker.get(obj)\n            const tracked = trackedObj && trackedObj.has(prop)\n            // If the function has been disposed or if the prop has not been used\n            // during the latest function call, delete the function reference\n            if(dependent.__disposed || tracker && !tracked) {\n              dependents.delete(dependent)\n            } else if(dependent !== computedStack[0]) {\n              // Run the computed function\n              if(typeof batch !== 'undefined' && batch !== false) {\n                enqueue(dependent, batch)\n                dependent[__batched] = true\n              } else {\n                dependent()\n              }\n            }\n          }\n        }\n\n        if (prop !== modifiedProperty) {\n        \tobj[modifiedProperty] = prop\n        \t\n\t        const dependents = propertiesMap.get(modifiedProperty)\n\t        if(dependents) {\n\t          // Retrieve the computed functions depending on \"modifiedProperty\"\n\t          for(const dependent of dependents) {\n\t            const tracker = dependent[trackerSymbol]\n\t            const trackedObj = tracker && tracker.get(obj)\n\t            const tracked = trackedObj && trackedObj.has(modifiedProperty)\n\t            // If the function has been disposed or if \"modifiedProperty\" has not been used\n\t            // during the latest function call, delete the function reference\n\t            if(dependent.__disposed || tracker && !tracked) {\n\t              dependents.delete(dependent)\n\t            } else if(dependent !== computedStack[0]) {\n\t              // Run the computed function\n\t              if(typeof batch !== 'undefined' && batch !== false) {\n\t                enqueue(dependent, batch)\n\t                dependent[__batched] = true\n\t              } else {\n\t                dependent()\n\t              }\n\t            }\n\t          }\n\t        }\n        }\n      }\n    }\n\n  // For each observed object, each property is mapped with a set of computed functions depending on this property.\n  // Whenever a property is set, we re-run each one of the functions stored inside the matching Set.\n  const propertiesMap = new Map()\n\n  // Proxify the object in order to intercept get/set on props\n  const proxy = new Proxy(obj, {\n    get(_, prop) {\n      if(prop === observedSymbol)\n        return true\n\n      // If the prop is watched\n      if(isWatched(prop)) {\n        // If a computed function is being run\n        if(computedStack.length) {\n          const computedFn = computedStack[0]\n          // Tracks object and properties accessed during the function call\n          const tracker = computedFn[trackerSymbol]\n          if(tracker) {\n            let trackerSet = tracker.get(obj)\n            if(!trackerSet) {\n              trackerSet = new Set()\n              tracker.set(obj, trackerSet)\n            }\n            trackerSet.add(prop)\n          }\n          // Link the computed function and the property being accessed\n          let propertiesSet = propertiesMap.get(prop)\n          if(!propertiesSet) {\n            propertiesSet = new Set()\n            propertiesMap.set(prop, propertiesSet)\n          }\n          propertiesSet.add(computedFn)\n        }\n      }\n\n      return obj[prop]\n    },\n    set(_, prop, value) {\n      setObjectPropertyTo(obj, prop, value)\n      return true\n    },\n    defineProperty(_, prop, descriptor) {\n      if (prop === '__handler') {\n      \tthrow new Error(\"Don't track bubble handlers\")\n      } else if(!isWatched(prop)) {\n        // If the prop is ignored\n        return Reflect.defineProperty(obj,prop,descriptor)\n      } else if (! Array.isArray(obj) || (prop === 'length')) {\n      \tif (('value' in descriptor) && deep && isObj(descriptor.value)) {\n      \t  descriptor = {...descriptor} // do not modify the argument itself\n      \t  descriptor.value = observe(descriptor.value, options)\n      \t}\n      \tconst Outcome = Reflect.defineProperty(obj,prop,descriptor)\n      \t  if (prop !== modifiedProperty) {\n\t        \tobj[modifiedProperty] = prop\n\t        }\n      \treturn Outcome\n      }\n      return false\n    },\n    deleteProperty(_, prop) {\n    \tif (prop === modifiedProperty) throw new Error(\n    \t  'internal property Symbol(\"modifiedProperty\") must not be deleted'\n    \t)\n\n    \tif (prop in obj) {\n    \t\tsetObjectPropertyTo(obj, prop, undefined) // trigger observers one last time\n    \t}\n    \treturn Reflect.deleteProperty(_,prop)\n    }\n  })\n\n  if(bind) {\n    // Need this for binding es6 classes methods which are stored in the object prototype\n    getInstanceMethodKeys(obj).forEach(key => obj[key] = obj[key].bind(proxy))\n  }\n\n  return proxy\n}\n\n/**** ValuesDiffer - copied from \"javascript-interface-library\", then modified ****/\n\n  function ValuesDiffer (thisValue, otherValue, Mode) {\n  \tconst visitedObjects = new Map()\n  \t\n  \tfunction ValuesDoDiffer (thisValue, otherValue, Mode) {\n\t    if (thisValue === otherValue) { return false }\n\t\n\t    let thisType = typeof thisValue\n\t    if (thisType !== typeof otherValue) { return true }\n\t\n    /**** ArraysDiffer ****/\n\n      function ArraysDiffer (thisArray, otherArray, Mode) {\n        if (! Array.isArray(otherArray)) { return true }\n\n        if (thisArray.length !== otherArray.length) { return true }\n\n        if (visitedObjects.has(thisArray) || visitedObjects.has(otherArray)) {\n        \tif (visitedObjects.has(thisArray)  && visitedObjects.get(thisArray).has(otherArray)) { return false }\n        \tif (visitedObjects.has(otherArray) && visitedObjects.get(otherArray).has(thisArray)) { return false }\n        \t\n        \tif (! visitedObjects.has(thisArray)) { visitedObjects.set(thisArray, new Set()) }\n        \tvisitedObjects.get(thisArray).add(otherArray)\n        }\n        \n        for (let i = 0, l = thisArray.length; i < l; i++) {\n          if (ValuesDoDiffer(thisArray[i],otherArray[i],Mode)) { return true }\n        }\n\n        return false\n      }\n\n    /**** ObjectsDiffer ****/\n\n      function ObjectsDiffer (thisObject, otherObject, Mode='by-value') {\n        if (Object.getPrototypeOf(thisObject) !== Object.getPrototypeOf(otherObject)) {\n          return true\n        }\n\n        for (let key in thisObject) {\n          if (! (key in otherObject)) { return true }\n        }\n\n        for (let key in otherObject) {\n          if (! (key in thisObject)) { return true }\n        }\n\n        if (visitedObjects.has(thisObject) || visitedObjects.has(otherObject)) {\n        \tif (visitedObjects.has(thisObject)  && visitedObjects.get(thisObject).has(otherObject)) { return false }\n        \tif (visitedObjects.has(otherObject) && visitedObjects.get(otherObject).has(thisObject)) { return false }\n        \t\n        \tif (! visitedObjects.has(thisObject)) { visitedObjects.set(thisObject, new Set()) }\n        \tvisitedObjects.get(thisObject).add(otherObject)\n        }\n\n        for (let key in thisObject) {\n          if (ValuesDoDiffer(thisObject[key],otherObject[key],Mode)) {\n            return true\n          }\n        }\n\n        return false\n      }\n\t\n\t    switch (thisType) {\n\t      case 'undefined':\n\t      case 'boolean':\n\t      case 'string':\n\t      case 'function': return true   // most primitives are compared using \"===\"\n\t      case 'number':   return (\n\t                         (isNaN(thisValue) !== isNaN(otherValue)) ||\n\t                         (Math.abs(thisValue-otherValue) > Number.EPSILON)\n\t                       )\n\t      case 'object':\n\t        if (thisValue  == null) { return true }  // since \"other_value\" != null!\n\t        if (otherValue == null) { return true }   // since \"this_value\" != null!\n\t\n\t        if ((Mode === 'by-value') && (\n\t          (thisValue instanceof Boolean) ||\n\t          (thisValue instanceof Number) ||\n\t          (thisValue instanceof String)\n\t        )) {\n\t          return (thisValue.valueOf() !== otherValue.valueOf())\n\t        }\n\t\n\t        if (Array.isArray(thisValue)) {\n\t          return ArraysDiffer(thisValue,otherValue,Mode)\n\t        }\n\t\n\t        return (\n\t          Mode === 'by-reference'\n\t          ? true                           // because (thisValue !== otherValue)\n\t          : ObjectsDiffer(thisValue,otherValue,Mode)\n\t        )\n\t      default: return true                          // unsupported property type\n\t    }\n\t\n\t    return true\n  \t}\n  \treturn ValuesDoDiffer(thisValue, otherValue, Mode)\n  }\n","import { data } from './data.js'\nconst { computedStack, trackerSymbol } = data\n\n/**\n * @typedef {Object} ComputedArguments - Computed Arguments.\n * @property {(fun: () => void) => void} computeAsync -\n * Will monitor the dependencies of the function passed as an argument. Useful when dealing with asynchronous computations.\n */\n\n/**\n * @typedef {Object} Options - Computed Options.\n * @property {boolean} [autoRun] -\n * If false, will not run the function argument when calling computed(function).\n * The computed function must be called **at least once** to calculate its dependencies.\n * @property {() => void} [callback] -\n * Specify a callback that will be re-runned each time a dependency changes instead of the computed function.\n */\n\n/**\n * Wraps a function and captures observed properties which are accessed during the function execution.\n * When those properties are mutated, the function is called to reflect the changes.\n *\n * @param {(args: ComputedArguments) => void} wrappedFunction\n * @param {Options} options\n */\nexport function computed(wrappedFunction, { autoRun = true, callback, bind, disableTracking = false } = {}) {\n  function observeComputation(fun, argsList = []) {\n    const target = callback || wrapper\n    // Track object and object properties accessed during this function call\n    if(!disableTracking) {\n      target[trackerSymbol] = new WeakMap()\n    }\n    // Store into the stack a reference to the computed function\n    computedStack.unshift(target)\n    // Inject the computeAsync argument which is used to manually declare when the computation takes part\n    if(argsList.length > 0) {\n      argsList = [...argsList, computeAsyncArg]\n    } else {\n      argsList = [computeAsyncArg]\n    }\n    // Run the computed function - or the async function\n    const result =\n      fun ? fun() :\n      bind ? wrappedFunction.apply(bind, argsList) :\n      wrappedFunction(...argsList)\n    // Remove the reference\n    computedStack.shift()\n    // Return the result\n    return result\n  }\n  const computeAsyncArg = { computeAsync: observeComputation }\n  const wrapper = (...argsList) => observeComputation(null, argsList)\n\n  // If autoRun, then call the function at once\n  if(autoRun) {\n    wrapper()\n  }\n\n  return wrapper\n}\n","import { observe, modifiedProperty } from './observe.js'\nimport { computed } from './computed.js'\nimport { dispose } from './dispose.js'\nimport { process } from './batcher.js'\n\nexport default {\n  observe, modifiedProperty,\n  computed,\n  dispose,\n  batch: process\n}\n","import { data } from './data.js'\n\n/**\n * Will remove the computed function from the reactive Maps (the next time an bound observer property is called) allowing garbage collection.\n *\n * @param {Function} computedFunction\n */\nexport function dispose(computedFunction) {\n  computedFunction[data.trackerSymbol] = null\n  return computedFunction.__disposed = true\n}\n","export const allHandler = function(handlers) {\n  return Array.isArray(handlers) ?\n    (keys, value, proxy) => handlers.forEach(fn => fn(keys, value, proxy)) :\n    handlers\n}","const getWriteContext = function(prop) {\n  return Number.isInteger(Number.parseInt(prop, 10)) ? [] : {}\n}\nexport const writeHandler = function(target) {\n  if(!target)\n    throw new Error('writeHandler needs a proper target !')\n  return function(props, value) {\n    value = typeof value === 'object' ?\n      JSON.parse(JSON.stringify(value)) :\n      value\n    for(let i = 0; i < props.length - 1; i++) {\n      var prop = props[i]\n      if(typeof target[prop] === 'undefined')\n        target[prop] = getWriteContext(props[i + 1])\n      target = target[prop]\n    }\n    target[props[props.length - 1]] = value\n  }\n}","import { allHandler } from './all.js'\nimport { debugHandler } from './debug.js'\nimport { writeHandler } from './write.js'\n\nexport default {\n  write: writeHandler,\n  debug: debugHandler,\n  all: allHandler\n}","import hyperactiv from '../index.js'\nimport handlers from '../handlers/index.js'\n\nconst { observe } = hyperactiv\n\nfunction send(socket, obj) {\n  socket.send(JSON.stringify(obj))\n}\n\nfunction findRemoteMethods({ target, autoExportMethods, stack = [], methods = [] }) {\n  if(typeof target === 'object') {\n    if(autoExportMethods) {\n      Object.entries(target).forEach(([key, value]) => {\n        if(typeof value === 'function') {\n          stack.push(key)\n          methods.push(stack.slice(0))\n          stack.pop()\n        }\n\n      })\n    } else if(target.__remoteMethods) {\n      if(!Array.isArray(target.__remoteMethods))\n        target.__remoteMethods = [ target.__remoteMethods ]\n      target.__remoteMethods.forEach(method => {\n        stack.push(method)\n        methods.push(stack.slice(0))\n        stack.pop()\n      })\n    }\n\n    Object.keys(target).forEach(key => {\n      stack.push(key)\n      findRemoteMethods({ target: target[key], autoExportMethods, stack, methods })\n      stack.pop()\n    })\n  }\n\n  return methods\n}\n\nfunction server(wss) {\n  wss.host = (data, options) => {\n    options = Object.assign({}, { deep: true, batch: true, bubble: true }, options || {})\n    const autoExportMethods = options.autoExportMethods\n    const obj = observe(data || {}, options)\n    obj.__handler = (keys, value, old) => {\n      wss.clients.forEach(client => {\n        if(client.readyState === 1) {\n          send(client, { type: 'update', keys: keys, value: value, old: old })\n        }\n      })\n    }\n\n    wss.on('connection', socket => {\n      socket.on('message', async message => {\n        if(message === 'sync') {\n          send(socket, { type: 'sync', state: obj, methods: findRemoteMethods({ target: obj, autoExportMethods }) })\n        } else {\n          message = JSON.parse(message)\n          // if(message.type && message.type === 'call') {\n          let cxt = obj, result = null, error = null\n          message.keys.forEach(key => cxt = cxt[key])\n          try {\n            result = await cxt(...message.args)\n          } catch(err) {\n            error = err.message\n          }\n          send(socket, { type: 'response', result, error, request: message.request })\n          // }\n        }\n      })\n    })\n    return obj\n  }\n  return wss\n}\n\nfunction client(ws, obj = {}) {\n  let id = 1\n  const cbs = {}\n  ws.on('message', msg => {\n    msg = JSON.parse(msg)\n    if(msg.type === 'sync') {\n      Object.assign(obj, msg.state)\n      msg.methods.forEach(keys => handlers.write(obj)(keys, async (...args) =>\n        new Promise((resolve, reject) => {\n          cbs[id] = { resolve, reject }\n          send(ws, { type: 'call', keys: keys, args: args, request: id++ })\n        })\n      ))\n    } else if(msg.type === 'update') {\n      handlers.write(obj)(msg.keys, msg.value)\n    } else /* if(msg.type === 'response') */{\n      if(msg.error) {\n        cbs[msg.request].reject(msg.error)\n      } else {\n        cbs[msg.request].resolve(msg.result)\n      }\n      delete cbs[msg.request]\n    }\n  })\n  ws.on('open', () => ws.send('sync'))\n  return obj\n}\n\nexport default {\n  server,\n  client\n}"],"names":["BIND_IGNORED","isObj","object","setHiddenKey","key","value","Object","defineProperty","enumerable","configurable","defineBubblingProperties","parent","data","computedStack","trackerSymbol","Symbol","queue","__batched","process","task","enqueue","batch","queueMicrotask","setTimeout","push","observedSymbol","modifiedProperty","hyperactiv","observe","obj","options","props","ignore","deep","bubble","bind","isWatched","prop","Array","includes","setObjectPropertyTo","isArray","thisValue","otherValue","Mode","visitedObjects","Map","ValuesDoDiffer","thisType","ArraysDiffer","thisArray","otherArray","length","has","get","set","Set","add","i","l","ObjectsDiffer","thisObject","otherObject","getPrototypeOf","isNaN","Math","abs","Number","EPSILON","Boolean","String","valueOf","ValuesDiffer","deeper","oldValue","ancestry","__handler","proxy","__key","__parent","unshift","dependents","propertiesMap","dependent","tracker","trackedObj","tracked","__disposed","delete","entries","forEach","val","Proxy","_","computedFn","trackerSet","propertiesSet","descriptor","Error","Reflect","Outcome","deleteProperty","undefined","getOwnPropertyNames","concat","indexOf","constructor","name","filter","computed","wrappedFunction","autoRun","callback","disableTracking","observeComputation","fun","argsList","target","wrapper","WeakMap","computeAsyncArg","result","apply","shift","computeAsync","dispose","computedFunction","getWriteContext","isInteger","parseInt","handlers","JSON","parse","stringify","send","socket","findRemoteMethods","autoExportMethods","stack","methods","slice","pop","__remoteMethods","method","keys","server$1","server","wss","host","assign","old","clients","client","readyState","type","on","async","message","state","cxt","error","args","err","request","ws","id","cbs","msg","Promise","resolve","reject"],"mappings":"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"}