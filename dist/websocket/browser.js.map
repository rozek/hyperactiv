{"version":3,"file":"browser.js","sources":["../../src/handlers/write.js","../../src/websocket/browser.js"],"sourcesContent":["const getWriteContext = function(prop) {\n  return Number.isInteger(Number.parseInt(prop, 10)) ? [] : {}\n}\nexport const writeHandler = function(target) {\n  if(!target)\n    throw new Error('writeHandler needs a proper target !')\n  return function(props, value) {\n    value = typeof value === 'object' ?\n      JSON.parse(JSON.stringify(value)) :\n      value\n    for(let i = 0; i < props.length - 1; i++) {\n      var prop = props[i]\n      if(typeof target[prop] === 'undefined')\n        target[prop] = getWriteContext(props[i + 1])\n      target = target[prop]\n    }\n    target[props[props.length - 1]] = value\n  }\n}","import { writeHandler } from '../handlers/write.js'\n\nexport default (url, obj, debug, timeout) => {\n  const cbs = {}, ws = new WebSocket(url || 'ws://localhost:8080'), update = writeHandler(obj)\n  let id = 0\n  ws.addEventListener('message', msg => {\n    msg = JSON.parse(msg.data)\n    if(debug)\n      debug(msg)\n    if(msg.type === 'sync') {\n      Object.assign(obj, msg.state)\n      if(Array.isArray(msg.methods)) {\n        msg.methods.forEach(keys => update(keys, async (...args) => {\n          ws.send(JSON.stringify({ type: 'call', keys: keys, args: args, request: ++id }))\n          return new Promise((resolve, reject) => {\n            cbs[id] = { resolve, reject }\n            setTimeout(() => {\n              delete cbs[id]\n              reject(new Error('Timeout on call to ' + keys))\n            }, timeout || 15000)\n          })\n        }))\n      }\n    } else if(msg.type === 'update') {\n      update(msg.keys, msg.value)\n    } else if(msg.type === 'response') {\n      if(msg.error) {\n        cbs[msg.request].reject(msg.error)\n      } else {\n        cbs[msg.request].resolve(msg.result)\n      }\n      delete cbs[msg.request]\n    }\n  })\n\n  ws.addEventListener('open', () => ws.send('sync'))\n}"],"names":["getWriteContext","prop","Number","isInteger","parseInt","url","obj","debug","timeout","cbs","ws","WebSocket","update","target","Error","props","value","JSON","parse","stringify","i","length","writeHandler","id","addEventListener","msg","data","type","Object","assign","state","Array","isArray","methods","forEach","keys","async","args","send","request","Promise","resolve","reject","setTimeout","error","result"],"mappings":"wPAAA,MAAMA,EAAkB,SAASC,GAC/B,OAAOC,OAAOC,UAAUD,OAAOE,SAASH,EAAM,KAAO,GAAK,CAAE,CAC9D,QCAe,CAACI,EAAKC,EAAKC,EAAOC,KAC/B,MAAMC,EAAM,CAAA,EAAIC,EAAK,IAAIC,UAAUN,GAAO,uBAAwBO,EDAxC,SAASC,GACnC,IAAIA,EACF,MAAM,IAAIC,MAAM,wCAClB,OAAO,SAASC,EAAOC,GACrBA,EAAyB,iBAAVA,EACbC,KAAKC,MAAMD,KAAKE,UAAUH,IAC1BA,EACF,IAAI,IAAII,EAAI,EAAGA,EAAIL,EAAMM,OAAS,EAAGD,IAAK,CACxC,IAAInB,EAAOc,EAAMK,QACU,IAAjBP,EAAOZ,KACfY,EAAOZ,GAAQD,EAAgBe,EAAMK,EAAI,KAC3CP,EAASA,EAAOZ,EACjB,CACDY,EAAOE,EAAMA,EAAMM,OAAS,IAAML,CACnC,CACH,CCf6EM,CAAahB,GACxF,IAAIiB,EAAK,EACTb,EAAGc,iBAAiB,WAAWC,IAC7BA,EAAMR,KAAKC,MAAMO,EAAIC,MAClBnB,GACDA,EAAMkB,GACQ,SAAbA,EAAIE,MACLC,OAAOC,OAAOvB,EAAKmB,EAAIK,OACpBC,MAAMC,QAAQP,EAAIQ,UACnBR,EAAIQ,QAAQC,SAAQC,GAAQvB,EAAOuB,GAAMC,SAAUC,KACjD3B,EAAG4B,KAAKrB,KAAKE,UAAU,CAAEQ,KAAM,OAAQQ,KAAMA,EAAME,KAAMA,EAAME,UAAWhB,KACnE,IAAIiB,SAAQ,CAACC,EAASC,KAC3BjC,EAAIc,GAAM,CAAEkB,UAASC,UACrBC,YAAW,YACFlC,EAAIc,GACXmB,EAAO,IAAI5B,MAAM,sBAAwBqB,GAAM,GAC9C3B,GAAW,KAAM,UAIL,WAAbiB,EAAIE,KACZf,EAAOa,EAAIU,KAAMV,EAAIT,OACA,aAAbS,EAAIE,OACTF,EAAImB,MACLnC,EAAIgB,EAAIc,SAASG,OAAOjB,EAAImB,OAE5BnC,EAAIgB,EAAIc,SAASE,QAAQhB,EAAIoB,eAExBpC,EAAIgB,EAAIc,SAChB,IAGH7B,EAAGc,iBAAiB,QAAQ,IAAMd,EAAG4B,KAAK,SAAQ"}